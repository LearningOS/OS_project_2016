\section{引言}

\subsection{项目背景}

本次实验，为挑战性课程的操统部分实验，是上个学期软件工程、计算机组成原理课程联合项目的后续。

承担本项目的开发者为计33班的李宇轩，董豪宇和梁泽宇同学。

和上学期一样，本次实验是一个软硬件协同开发的工作，因此要求开发者既能够理解CPU的底层实现，也能够了解在此基础上的操作系统的行为。不同的是，由于是进行功能扩展，三个人分别进行不同的扩展，工作相对于较为独立。

具体分工为，董豪宇同学负责文件系统的修改，梁泽宇同学负责网络模块的支持，李宇轩同学则负责Debugger模块和处理一些硬件问题。

本文将总结我——李宇轩部分的工作——串口，Flash和Debugger模块。

\subsection{编写目的}
编写此文档的目的主要在于总结现阶段工作，并且为之后的学弟提供相应地支持与便利。

\subsection{文档结构}
先从较为简单的串口入手，再解释Flash的相关工作，最后则是工作的重心Debugger模块。

\subsection{我的分工}
我在本次课程设计中，完成的工作为较为独立地实现串口、Flash和Debugger模块。具体的工作本文接下来的篇幅将会具体讲解。

% ===================================================================================

\section{串口模块}
\subsection{基本介绍}
计算机内部数据通常以字或字节为单位进行并行访问。但与外部设备进行数据交互或与其他计算机进行通信时，也经常需要串行数据通信。串行接口是一类使用相对简单的接口，thinpad教学计算机上也配置了基本的串口，作为连接中断设备的接口。

\subsection{实验需求}
ucore和所有的操作系统一样，可以提供最基本的I/O支持。实现这个I/O我们有很多的方法。比如说通过VGA显示，通过PS2键盘输入。但是有更简单的方式，就是直接通过串口通信来同时支持操统的数据输入和输出数据的显示。其中数据的输入就是操统接受到串口传递过来的数据，而数据的显示则是将需要显示的字符发送给远端的PC计算机，在PC计算机上的串口通信终端上显示。

上学期已将基本的串口实现，但是通过测试发现，使用上学期的串口传文件有着严重丢包情况产生，这就使得我们不得不得学习一些跨时钟域通信的协议，写一个鲁棒的串口通信模块。

\subsection{实现原理}
采样部分可以使用www.fpga4fun.org的现成代码，具体原理大概是取多个采样点的中点，一般来说中点的信号比较稳定。

我们假设cpu处于一个快时钟域，串口处于一个慢时钟域（分别为25M和11M）。快时钟域向慢时钟域通信的时候，可以使用脉冲同步器；慢时钟域向快时钟域同步，可以使用边沿同步器。

此外，还需要走两层触发器，防止亚稳态的产生。

只要注意了这些细节，实现一个能在115200波特率下工作的串口模块，应当是没有问题的。

\subsection{测试方案}
由于寒假就研究了串口丢包的相关问题，所以串口的实现相对来说是比较简单的。关键工程量就在于测试。

这里采用的测试方法是，pc端反复发送"12345678"字符串，在写好的串口模块的基础上搭一个test\_bench，test\_bench每次将收到的字符发送回pc端。如果看到12345678丢失了几个字符导致了pc端终端输出不对弃，则认为串口没有稳定工作。否则则认为串口已经稳定。

之所以这样考虑的原因，是之前观察了串口出错的情况，可以发现肯定是由于丢包而不是误传。在这个假定的基础上，我们认为这样一个检验是基本合理的，如果需要进一步检查，可以把收到的数据使用工具比对。

具体的test\_bench代码见git工程下work\_JFLFY/vhdl\_src/test\_com。

\subsection{遇到的问题}
调试串口的过程中未遇到明显的问题。

\subsection{实现成果}
我们实现的串口通过了设计的测试方案，能在这个test\_bench下稳定传输至少1小时。此外，通过回环测试我测试出了当时使用串口自发自收的最高波特率，为430400，并且在这个速率下串口也能完全正常工作。

到这里为止，认为串口实验的结果非常理想，满足要求。


%======================================================================== 


\section{Flash模块}
\subsection{基本介绍}
Flash是存储芯片的一种，通过特定的程序可以修改其中存储的数据。Flash存储器又称为闪存，它结合了ROM和RAM的长处，不禁具备电子可擦除和可编程的功能，还能够快速读取数据，Flash不像普通的闪存，保存的数据断电后也不会丢失。

thinpad中的Flash型号为MT28F640J3，一共8MB的空间，支持16位数据的存取操作。

\subsection{实验需求}
先看看上个学期计软联合大实验的要求：

\begin{quote}
thinpad的Flash被定位为一个很简单的外存。这个外存提供操作系统的断电存储。所以事实上，仅仅需要支持Flash的读取操作即可，无需支持其写入操作。ucore操统没有在Flash上支持文件的写入。
\end{quote}

这学期，我们需要在将sfs文件系统进行扩展，使其支持新增、删除文件。由于这个文件系统需要被实现在Flash上，我们的CPU需要完整的支持对于Flash的erase和write。

\subsection{实现原理}
关于MT28F640J3 \ Flash，可以参考的资料主要有上学期的《计算机硬件实验原理》和该芯片的datasheet。我分别阅读了这两个资料，发现《计算机硬件实验原理》上面的描述虽然是正确的，但是不够完备、准确。

具体来说，flash具有的基本特性是，只能把一位上的1写成0，而不能把0写成1。所以为了实现往Flash存入信息，需要同时实现Flash的erase和write操作。

对于Flash的操作满足这样一个模式，先往地址里面写入一个操作码，之后紧跟着的指令就可以执行相应的read, erase和write操作。他们三者的状态机如下：
\begin{itemize}
\item read的状态机：向Flash的任意地址中先写入一个0xff，表示转换到读Flash模式。
\item write的状态机：向要写入Flash的对应地址中写入一个0x40，表示转换到写“字”模式；再往该地址写入需要写入的值。这时候Flash会将读模式切换为读状态寄存器模式，从任意地址中读出状态寄存器的值，直到第八位为1表示写入完毕，方可进行下一个操作。
\item erase的状态机：向要写入Flash的对应的块地址中写入一个0x20，表示转换到写“字”模式；再往该块地址中写入0xD0表示erase。\footnote{实测不需要是块开头的地址，写的地址属于哪个块，Flash就会清空哪个块}这时候Flash会将读模式切换为读状态寄存器模式，从任意地址中读出状态寄存器的值，直到第八位为1表示写入完毕，方可进行下一个操作。
\end{itemize}

知道了前面的那些协议知识，就可以着手实现Flash通讯模块了。我实现Flash的时候较早，当时文件系统的工作还没有步入正轨，还不知道需要将Flash的接口设计成什么样子。所以我实现了两种不同层次Flash接口，一个接口对外暴露了Flash先指令后操作的特性，完全通过前面描述的状态机来操作Flash，需要操统有简单的Flash驱动，才能使用这个接口；另一个接口则封装了那个简单的接口，使用这个接口，ucore可以像访问ram一样访问flash，只是erase需要hack一条特殊的指令。

当然，最终被选择的是前者，这个模块更为灵活，用软件驱动操作Flash模块更灵活，比如可以支持队友董豪宇实现异步擦除操作。

\subsection{测试方案}
\subsubsection{测试方案A}

我对Flash进行的第一个测试，是通过前面描述的第二个Flash接口实现的。可以说这也是当时为何实现这样一个接口的原因，因为有了这样一个可以简单使用的接口，就可以使用以前给ram搭的test\_bench直接进行对于Flash的测试。

测试是逐步进行的。先将clk设置成手动触发，检测erase功能，用test\_bench清空Flash的一个块，在用其他的工具观察这个块的值。通过了第一步以后，再检测write功能，往Flash中反复写入“12345678”，再用其他的工具观察。经观察无误后，最后测试Flash的读取，依次读取Flash，判断读出的内容是否为“12345678”。

最后取消手动clk模式，尝试Flash模块能在什么样的时钟下运行，和datasheet进行比对，查看实现上面是否有能导致需降频的瑕疵。

这个测试简单而有效，经过测试的Flash是能正常工作。


\subsubsection{测试方案B}
对于Flash的第二次测试是在将已经写好的Flash模块放入CPU时进行的。由于此时我的Debugger模块已经正常工作，可以稳定地从ram中读取大量数据，也可以直接作为ram的烧写器。我就将Flash模块放入操统后，进行了简单的修改，支持了Debugger模块对于Flash的访问。

只要Debugger可以成为Flash的烧写器，并且操统可以正常从Flash启动，大致就可以认为Flash模块正确。但，在接下来的“遇到的问题”小节我们将看到，这个测试看起来十分完美，但是存在检查不出的问题，从而对我们的课程设计产生了巨大的影响。

\subsubsection{测试方案C}
这个测试方案与其表达为测试方案，不如说是一个最终目标之一。即支持一个有新版sfs文件系统的ucore。

我们组的情况是这个ucore在qemu下已经跑通了，可认为其基本正确，只要将其上板测试即可作为最后的测例。

\subsection{遇到的问题}
\subsubsection{问题一}
在测试方案A中没有遇到明显的问题。

在测试方案B和C中，出现了通过B却无法通过C的情况。这个问题也是导致我们14周演示效果不佳的原因。具体来说，就是能够正常的烧写ucore进Flash，暂停代码使用Debugger访问Flash也完全正常，但一旦运行代码就会问题。

通过使用Debugger观察Flash的运行结果，可以发现其会在莫名其妙的地方转换读模式。而Flash转换读模式的只可能是因为向Flash的某个地址写入了操作指令。然而问题在于，这段代码明明不应该有写入Flash的过程，却产生了写入Flash的效果。

我最初的猜想是Flash运行的时钟频率太高，导致操统运行不稳定。但这个Flash使能信号出问题，是很难通过常规手段调试的，需要示波器、逻辑分析仪类似的手段才会比较方便。在调试毫无进展的时候，巧合地发现我不小心将一个'w'写成了'o'，使得在某些情况下，会让读使能更新写使能，这是Flash出错的最终原因。不难发现，这个问题将会导致之前的诡异情况出现。比如之所以能通过测试B而无法通过测试C，是因为测试B不会交替进行读和写，从而不会误更新写使能，而测试C却无法避免会触及这一错误。

\subsubsection{问题二}
问题二是第十六周最终检测时候第一次遇到的。在ucore和CPU都没有重新编译的情况下，ucore在板上运行到的erase Flash block 0的时候，突然就卡死。

这个问题当场的解决比较巧合，随便使用Debugger运行了几个其他程序之后，这个问题就解决了。通过和张宇翔同学的讨论，我们认为之所以卡死是因为Flash在上次断电的时候正在工作，从而锁定了该block，导致一切操作无效。

非正常情况断电会锁定block的这一特性在datasheet中是有相关说明的。


\subsection{实现成果}
最终两版Flash代码均能正常工作，前一版在3.125M的CPU下正常工作，后一版在25M的CPU下正常工作。可以清空，写入，从Flash启动操作系统，并且能使用Debugger模块正常地操纵Flash，使用从Debugger模块改装的工具将ucore正确的烧入Flash中，可以作为一个不错的烧Flash工具。


%======================================================================== 


\section{Debugger模块}
\subsection{基本介绍}
调试是开发过程中必不可少的环节，通用的桌面操作系统与嵌入式操作系统在调试环境上存在明显的差别。前者，调试器与被调试的程序往往是运行在同一台机器、相同的操作系统上的两个进程，调试器进程通过操作系统专门提供的调用接口控制、访问被调试进程。后者，又称为远程调试，为了向系统开发人员提供灵活、方便的调试界面，调试器还是运行于通用桌面操作系统的应用程序，被调试的程序则运行于基于特定硬件平台的嵌入式操作系统。

嵌入式带来以下问题：调试器与被调试程序如何通信，被调试程序产生异常如何及时通知调试器，调试器如何控制、访问被调试程序，调试器如何识别有关被调试程序的多任务信息并控制某一特定任务，调试器如何处理某些与目标硬件平台相关的信息（如目标平台的寄存器信息、机器代码的反汇编等）。

一般来说有两种方式，一是通过插桩，在目标操作系统和调试器内分别加入某些功能模块，二者互通信息来进行调试，一般用于调试用户态。二是片上调试，在处理器内部嵌入额外的控制模块，当满足了一定的触发条件时进入某种特殊状态，从而达到debug的目的，一般由于调试内核。

本次课程设计我需要实现的Debugger，可以说就是一个嵌入式调试工具，这里通过片上调试模块的方式来解决调试问题。

\subsection{实验需求}
之前的一节已经将背景知识介绍的相对清楚了，本次实验的需求就是实现一个可以和GDB交互的片上调试模块，能正确地调试ucore内核。

\subsection{实现原理}

\subsubsection{RSP协议初步}
一开始接触到Debugger这个题目，相对来说是没有头绪的。那么任务之处就是调研自己究竟需要了解些什么。通过在网上搜索GDB远端调试，逐步寻找找到了GDB RSP协议，全称GDB Remote Serial Protocol。

经过筛选，可以发现\href{http://www.embecosm.com/appnotes/ean4/embecosm-howto-rsp-server-ean4-issue-2.html}，\href{https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html}，这两篇文章可以很好的，较为完整的了解这个所谓的RSP协议。

前一篇文章是一篇讲解性的文章，首先通过这篇文章我了解的是知道RSP的基本格式：
\begin{itemize}
\item 读寄存器组：（“g”），eg：\$g\#67；reply： +\$123456789abcdef0…\#xx
\item 写寄存器组：（“G”），eg：\$G123456789abcdef0…\#xx；reply：+\$OK\#9a
\item 单步命令（“s”），eg：\$s\#73
\item 继续命令（“c”），eg：\$c\#63
\end{itemize}

可以看出，这是一个一个字符代表一个指令的字符协议。+号表示reply，\#号后面跟着是校验和。通过观察指令和自己对于GDB实现的猜测，对于一个相对完备的GDB片上调试模块，应该只需要支持单步调试“s”、继续运行“c”、读写寄存器“gG”，读写内存“mM”。比如软断点，就可以通过写内存实现。而例如b if i==0，这类的指令，则是通过每次到达断点都暂停后判断是否继续运行达成的。

之后这篇文章有些gdb交互的例子画成的图，对于理解也是很有帮助的，在这里就不贴出了。

而第二篇文档是GDB的官方文档。这个文档作为一个字典也是很棒的，可以查到你通讯过程用到所有指令的含义，以及合法的reply方式。

\subsubsection{RSP协议实验}
通过阅读文章，了解RSP协议的大部分内容，但是对于一个完全陌生的协议，没有一个可以运行的程序供于调试学习的话，可能并不能很快的上手。尤其是虽然能明白交互，但是不太清楚一开始的初始化交互部分。

我选择了自己建立一个中转站，输出Debug模式下的qemu和gdb的交互结果（见work\_JFLFY/net\_agent）。通过观察它们的交互，并对照指令含义表，我了解了初始化部分的交互，也进一步对于调试部分产生了印象，之前对于GDB实现的猜测，在这里也完全得到了证实。具体一点，能得到的、阅读文档无法知道的信息有：如果你不支持一条指令，你就返回空，GDB会主动去寻找有代替效果的指令再来询问你的Debugger。

但之后有了更好的途径去了解这个协议。naive-debugger是上个学期张宇翔CPU组实现的一个简单的Debugger的pc端，通过阅读naive组的代码也是对于RSP协议的进一步加强理解。

\subsubsection{Debugger初步}
之后就可以开始Debugger的实现了。在这个最初的版本里，我参照了naive组的实现，使用了naive组pc端的server，使用它现有的那套协议和片上调试模块通信。这是一个二进制协议，相比原始的RSP协议简单了不少，更加适合硬件实现。

首先需要有一个独立的Debugger模块，这个模块维护自己的一个状态机，肩负着通过串口接受指令以及通过串口回复返回值的功能。只要有一定的硬件开发经验，这个模块还是比较好实现的。

通过把寄存器接线接到Debugger模块，实现Debugger模块对于寄存器的读取。

通过用Debugger模块送出的地址覆盖CPU给TLB模块的地址，可以让Debugger控制ram，从而能实现内存的读取。

为了支持暂停和单步调试，需要设计一个巧妙而鲁棒的暂停规则，这里我当时没有仔细想好，一度浪费了不少时间。

值得注意的是，在这里，调试的时候，将CPU流水线暂停而不是刷空（这样其实是不太好的，不能正确支持写寄存器、软中断这些的，原因下节会具体说明）。

\subsubsection{功能扩展}
第一次扩展的时候，我加入了写寄存器和写内存的功能。

为了实现写寄存器的功能，需要把数据传到通用寄存器堆模块，并且需要传递一个写使能。但事实上，这个功能当时是有问题的。这是由于只暂停流水而不清空流水导致的。

为了实现写内存，只需要传递一个写使能给MMU模块，并利用这个使能控制读写。剩下的逻辑读内存的时候基本已经实现。值得一提的是，写内存不会出现上面写寄存器的问题。

第二次扩展的时候，我加入了多个硬断点、disable断点、GDB控制的暂停、开关控制启动断点、流水线的清空、软断点和观察点功能。下面分别简单的讲解每个扩展的思路：
\begin{enumerate}
\item 多个硬断点：将原来的一个硬断点比较逻辑扩充，比较所有硬断点
\item disable断点：新增一条协议用于disable断点，只要修改一个硬断点在硬件上对应的使能位即可。
\item GDB控制的暂停：新增一条stop协议，用于强行停住正在运行的代码。pc端的server需要新开一个线程，原来的线程接受来自CPU的中断信号，新开的线程接受来自GDB的中断信号，一旦有一个中断信号就表示程序停止了。
\item 开关控制启动断点：之前的版本里，CPU一开始不会自己开始运行，而是停在0xb0000000这个起始地址，需要来自GDB的"c"才能正常运行。在这里变为用板上的一个开关控制0xb0000000断点的使能，可以正常启动，也可以暂停在0xb0000000。
\item 流水线的清空：将单纯的，需要对于整个CPU流水部分的逻辑进行不小的修改。具体的修改因CPU实现不同而不同，在此不赘述。
\item 软断点：在有了流水线的清空后，只需要识别break指令，并且在暂停规则那里加上一条相关的判断即可。
\item 观察点：和硬断点的实现类似，只是不再是对于指令地址进行暂停，而是对于访存地址进行暂停，两者硬件上的逻辑类似。需要区分watch, awatch和rwatch。
\end{enumerate}


\subsection{测试方案}
Debugger的测试相对于其他的模块来说，方法相对简单直白。就是每次新增一个功能以后，进入调试模式试试功能是否能正常运行。这次开发的过程中，一般来说这个方法都能较快的将Debugger的代码调试正确。

下一节将会描述调试过程中遇到的一些比较关键的问题。

\subsection{遇到的问题}
\subsubsection{问题一}
无法正确暂停。这个就是暂停规则细节一直没有想清楚导致的，经过了5、6次的修改，以及漫长编译的等待以后就解决了。
\subsubsection{问题二}
寄存器无法正常更新。

其实这个问题的出现，才让我意识到了，只流水线暂停而不流水线清空，是不太正确的调试暂停的逻辑。最明显，写寄存器操作会出错。因为你在暂停流水的时候，修改了一个寄存器的值。流水线再度启动的时候，虽然你寄存器的值已经修改，但是位于EX已经在更早的时候读取过了寄存器，并保留着未被修改的值进行接下来的运算，这导致的就是你的修改无效。

为了避免这种情况的发生，需要使用流水线暂停的逻辑。这样本来已经到EX阶段的指令将会重新执行，就不存在前面的问题了。

当时调试的时候，发现了改寄存器存在这个问题，是通过思考想到而解决的。总的来说，这个问题虽然很严重，但调试的时候相对顺利。

\subsection{实现成果}
我的Debugger模块能稳定地运行，在本次课程也对于我们调试操统起到了极大的帮助。支持的指令主要有：
\begin{enumerate}
\item step,next,continue
\item break,hbreak(+ if *)
\item watch,awatch,rwatch
\item bt,finish
\item x,p,disp,set var *=
\item ...
\end{enumerate}

\subsection{使用说明}
使用方面，并不是一个很麻烦的问题。

首先你需要根据你的pl2303串口（片上的那个USB串口）绑定的文件，修改naive-debugger文件夹中的naive\_mips.c串口相关的初始化部分。然后make，在当前目录下得到的naive-debugger就是可执行文件。

运行naive-debugger后，使用gdb的target remote :1234连接naive-debugger（为了方便调试你可以导入符号表），就可以像正常的GDB调试代码一样使用了。


%======================================================================== 


\section{心得}
在本次课程设计中，我有四大收获，一是在做ucore lab的阶段，把自己对于操作系统的理解提升了一个档次；第二，是由于本次分工中我主要负责硬件部分，进一步提升了自己的硬件设计、调试能力；然后是，在调试Flash的过程中，我学会、并习惯了阅读芯片的datasheet，这对外设调试是不可或缺的能力；最后，研究片上调试模块、GDB RSP协议也让我受益匪浅，不但让我独立完成了一个Debugger的编码，而且让我对于GDB的使用也有了新的理解，这对我以后的动作都有极大的裨益。

当然，本次课程设计中，我们组也存在严重的不足，那就是缺乏沟通。应该建立更好的团队关系，这样我们肯定能在期末的检查中取得更好的成果。
